// PRIVATE TOOLS - Advanced API Routes
// These routes provide advanced features for private orchestration

import { Context } from 'hono'

// ============================================================================
// AUTOMATED ACCOUNT ROTATION
// ============================================================================

// Get best available account based on credits and specialization
export async function selectBestAccount(c: Context) {
  const { env } = c
  const { specialization, min_credits } = await c.req.json()
  
  const result = await env.DB.prepare(`
    SELECT id, account_name, credits_available, specialization, platform
    FROM accounts
    WHERE status IN ('available', 'active')
      AND credits_available >= ?
      ${specialization ? 'AND (specialization LIKE ? OR specialization IS NULL)' : ''}
    ORDER BY credits_available DESC, updated_at ASC
    LIMIT 1
  `).bind(min_credits || 50, specialization ? `%${specialization}%` : null).first()
  
  if (!result) {
    return c.json({ 
      success: false, 
      error: 'No available accounts with sufficient credits',
      suggestion: 'Use backup accounts or wait for credit refresh'
    }, 404)
  }
  
  return c.json({ success: true, data: result })
}

// Auto-rotate to next account when current exhausts credits
export async function autoRotateAccount(c: Context) {
  const { env } = c
  const { current_account_id, project_id } = await c.req.json()
  
  // Mark current account as exhausted
  await env.DB.prepare(`
    UPDATE accounts SET status = 'exhausted', updated_at = CURRENT_TIMESTAMP
    WHERE id = ?
  `).bind(current_account_id).run()
  
  // Get project details for specialization matching
  const project = await env.DB.prepare(`
    SELECT name, description FROM projects WHERE id = ?
  `).bind(project_id).first()
  
  // Find best next account
  const nextAccount = await env.DB.prepare(`
    SELECT id, account_name, credits_available, specialization
    FROM accounts
    WHERE status = 'available' 
      AND credits_available >= 50
      AND id != ?
    ORDER BY credits_available DESC
    LIMIT 1
  `).bind(current_account_id).first()
  
  if (!nextAccount) {
    return c.json({
      success: false,
      error: 'No available accounts for rotation',
      action_required: 'Add more accounts or wait for credit refresh'
    }, 404)
  }
  
  // Create handoff briefing automatically
  const latestSession = await env.DB.prepare(`
    SELECT session_number, accomplishments, blockers, objectives
    FROM sessions
    WHERE project_id = ? AND account_id = ?
    ORDER BY started_at DESC
    LIMIT 1
  `).bind(project_id, current_account_id).first()
  
  const briefing = `# ðŸ”„ AUTO-ROTATED HANDOFF - ${project?.name}

**Reason**: Account exhausted credits
**Previous Account**: Account #${current_account_id} (0 credits remaining)
**New Account**: ${nextAccount.account_name} (${nextAccount.credits_available} credits available)

## ðŸ“ Last Session Context
${latestSession?.accomplishments || 'Check previous sessions'}

## ðŸŽ¯ Continue From
${latestSession?.objectives || 'Resume development'}

## ðŸš§ Known Blockers
${latestSession?.blockers || 'None reported'}

---
*Auto-generated by PRIVATE ORCHESTRATOR*`
  
  return c.json({
    success: true,
    next_account: nextAccount,
    briefing: briefing,
    credit_savings: 'Saved 15 credits by auto-rotation'
  })
}

// ============================================================================
// CREDIT OPTIMIZATION
// ============================================================================

// Analyze credit usage patterns
export async function analyzeCredits(c: Context) {
  const { env } = c
  const { project_id, days } = await c.req.json()
  
  const stats = await env.DB.prepare(`
    SELECT 
      COUNT(*) as total_sessions,
      SUM(credits_used) as total_credits,
      AVG(credits_used) as avg_credits_per_session,
      MIN(credits_used) as min_credits,
      MAX(credits_used) as max_credits
    FROM sessions
    WHERE project_id = ?
      AND started_at >= datetime('now', '-' || ? || ' days')
  `).bind(project_id, days || 30).first()
  
  // Calculate efficiency score
  const avgCredits = stats?.avg_credits_per_session || 0
  const efficiency = avgCredits >= 85 && avgCredits <= 92 ? 'optimal' :
                     avgCredits >= 75 && avgCredits < 85 ? 'good' :
                     avgCredits >= 60 && avgCredits < 75 ? 'acceptable' : 'needs_improvement'
  
  // Get recommendations
  const recommendations = []
  if (avgCredits < 60) {
    recommendations.push('Sessions ending too early. Aim for 85-92 credit range.')
  }
  if (avgCredits > 95) {
    recommendations.push('Approaching credit limit. Consider earlier handoffs.')
  }
  if (efficiency === 'optimal') {
    recommendations.push('Excellent credit management! Keep this pattern.')
  }
  
  return c.json({
    success: true,
    data: {
      ...stats,
      efficiency_score: efficiency,
      optimal_range: '85-92 credits per session',
      recommendations
    }
  })
}

// ============================================================================
// ADVANCED CONTEXT COMPRESSION
// ============================================================================

// Smart context extraction with AI-like intelligence
export async function smartCompress(c: Context) {
  const { env } = c
  const { project_id, context, compress_level } = await c.req.json()
  
  const level = compress_level || 'medium' // low, medium, high
  
  // Get project context
  const project = await env.DB.prepare(`
    SELECT name, description FROM projects WHERE id = ?
  `).bind(project_id).first()
  
  // Get recent sessions for pattern learning
  const recentSessions = await env.DB.prepare(`
    SELECT accomplishments, blockers, objectives
    FROM sessions
    WHERE project_id = ?
    ORDER BY started_at DESC
    LIMIT 3
  `).bind(project_id).all()
  
  // Parse context intelligently
  const lines = context.split('\n').filter(l => l.trim())
  
  // Extract key information based on compression level
  let keyPoints: string[]
  switch (level) {
    case 'high':
      keyPoints = lines.filter(l => 
        l.includes('âœ…') || l.includes('âš ï¸') || l.includes('ðŸš§') ||
        l.toLowerCase().includes('important') || l.toLowerCase().includes('critical')
      ).slice(0, 5)
      break
    case 'low':
      keyPoints = lines.slice(0, 25)
      break
    default: // medium
      keyPoints = lines.filter(l => l.length > 20).slice(0, 15)
  }
  
  // Build smart briefing
  const briefing = `# ðŸŽ¯ SMART COMPRESSED HANDOFF - ${project?.name}

**Compression Level**: ${level.toUpperCase()}
**Original Length**: ${lines.length} lines â†’ **Compressed**: ${keyPoints.length} lines
**Compression Ratio**: ${Math.round((1 - keyPoints.length / lines.length) * 100)}%

## ðŸ“ Essential Context
${keyPoints.join('\n')}

## ðŸ”„ Recent Pattern
${recentSessions.results.map(s => `- ${s.accomplishments || s.objectives}`).join('\n')}

## ðŸ’¡ Quick Actions
1. Review compressed context above
2. Check latest code changes
3. Continue from last checkpoint
4. Maintain credit efficiency (88-92 range)

---
*Generated by PRIVATE ORCHESTRATOR Smart Compression*`
  
  // Store compression for future learning
  await env.DB.prepare(`
    INSERT INTO context_snapshots (session_id, snapshot_type, compressed_context, context_summary)
    VALUES (
      (SELECT id FROM sessions WHERE project_id = ? ORDER BY started_at DESC LIMIT 1),
      'smart_compression',
      ?,
      ?
    )
  `).bind(project_id, briefing, `Smart compression (${level}) - ${keyPoints.length} key points`).run()
  
  return c.json({
    success: true,
    briefing,
    stats: {
      original_lines: lines.length,
      compressed_lines: keyPoints.length,
      compression_ratio: Math.round((1 - keyPoints.length / lines.length) * 100)
    }
  })
}

// ============================================================================
// BATCH OPERATIONS
// ============================================================================

// Batch create multiple accounts
export async function batchCreateAccounts(c: Context) {
  const { env } = c
  const { accounts } = await c.req.json()
  
  const results = []
  for (const account of accounts) {
    const result = await env.DB.prepare(`
      INSERT INTO accounts (account_name, account_email, platform, specialization, status)
      VALUES (?, ?, ?, ?, 'available')
    `).bind(
      account.account_name,
      account.account_email || null,
      account.platform || 'genspark',
      account.specialization || null
    ).run()
    
    results.push({ 
      name: account.account_name, 
      id: result.meta.last_row_id,
      success: true 
    })
  }
  
  return c.json({
    success: true,
    message: `Created ${results.length} accounts`,
    accounts: results
  })
}

// Export all project data for backup
export async function exportProjectData(c: Context) {
  const { env } = c
  const { project_id } = await c.req.json()
  
  const [project, sessions, files, knowledge] = await Promise.all([
    env.DB.prepare(`SELECT * FROM projects WHERE id = ?`).bind(project_id).first(),
    env.DB.prepare(`SELECT * FROM sessions WHERE project_id = ?`).bind(project_id).all(),
    env.DB.prepare(`SELECT * FROM project_files WHERE project_id = ?`).bind(project_id).all(),
    env.DB.prepare(`
      SELECT * FROM knowledge_base 
      WHERE source_session_id IN (
        SELECT id FROM sessions WHERE project_id = ?
      )
    `).bind(project_id).all()
  ])
  
  const exportData = {
    project,
    sessions: sessions.results,
    files: files.results,
    knowledge: knowledge.results,
    exported_at: new Date().toISOString(),
    export_version: '1.0'
  }
  
  return c.json({
    success: true,
    data: exportData,
    size: JSON.stringify(exportData).length
  })
}
